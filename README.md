# CHIP8 Interpreter

## Устройство эмуляора

По сути просто пишем эмулфтор для платформы chip8.  
Тесты вязты [тут](https://github.com/Timendus/chip8-test-suite#corax-opcode-test)  
Описание инструкций [тут](https://chip8.gulrak.net/)

### Память

- 16 регистров каждый по 8 бит
- Один адресный регистр размером в 12 бит
- 4 килобайта памяти
- Стек на 16 последних адресов возврата
- Адрес следующей команды на исполнение

### Инструкции

Каждая инструкция состоит из 16 бит. Всего инструкций 34. Условно разделить их можно на несколько категорий

### Условия

**3XNN**  
Done
Пропустить следующую инструкцию если `vX == NN`.

**4XNN**  
Done
Пропустить следующую инструкцию если `vX != NN`.

**5XY0**  
Done
Пропустить следующую инструкцию если `vX == vY`.

**9XY0**  
Done
Пропустить следующую инструкцию если `vX != vY`.

**EX9E**  
Пропустить следующую инструкцию если клавиша в 4 младших битах регистра `vX` нажата.

**EXA1**  
Пропустить следующую инструкцию если клавиша в 4 младших битах регистра `vX` отжата.

### Запись регистров

**6XNN**  
Done
Установить в регистр `vX` значение `NN`.

**8XY0**  
Done
Установить в регистр `vX` значение регистра `vY`.

**ANNN**  
Done
Установить адресному регистру `I` значение `NNN`.

**CXNN**  
Done
Установить в регистр `vX` случайное значение с маской `NN` через `AND`.

**FX07**  
Установить в регистр `vX` значение таймера задержки.

**FX55**  
Done
Записать значения регистров с `v0` до `vX` в память начиная с адресса в `I`.

**FX65**  
Done
Загрузить значения регистров с `v0` до `vX` значениями из памяти начиная с адресса в `I`.

**FX33**  
Done
Записать значение в регистре `vx` в виде двоично-десятичного кода(BCD) по адресам `I`, `I + 1` и `I + 2`.

### Математические операции

**7XNN**  
Done
Прибавить в регистр `vX` значение `NN`.

**8XY1**  
Done
Установить в регистр `vX` значение `vX OR vY`.

**8XY2**  
Done
Установить в регистр `vX` значение `vX AND vY`.

**8XY3**  
Done
Установить в регистр `vX` значение `vX XOR vY`.

**FX1E**  
Done
Прибавить в адресный регистр `I` значение регистра `vX`.

**8XY4**  
Done
Прибавить в регистр `vX` значение регистра `vY`. В регистр `vF` установить 1 если случилось переполнение, в противном случае установить 0.

**8XY5**  
Done
Вычесть из регистра `vX` значение регистра `vY`. В регистр `vF` установить 0 если случилось антипереполнение, в противном случае установить 1.

**8XY6**  
Done
Установить в регистр `vX` значение регистра `vY` и сдвинуть значение регистра `vX` на 1 бит вправо. В регистр `vF` установить значение вытесненного бита.

**8XY7**
Done  
Установить в регистр `vX` значение результата `vY - vX`. В регистр `vF` установить 0 если случилось антипереполнение, в противном случае установить 1.

**8XYE**
Done
Установить в регистр `vX` значение регистра `vY` и сдвинуть значение регистра `vX` на 1 бит влево. В регистр `vF` установить значение вытесненного бита.

### Экран

**00E0**  
Done
Очистка экрана. Очищает буффер экрана и гасит каждый пиксель.

**DXYN**  
Done
Написовать спрайт размером `8 x N` пикселей начиная с позиции `vX`, `vY`. Данные спрайта храняться в памяти в виде последовательности байт по адресам `I`..`I + N`. Каждый байт это один ряд пикселей. Каждый ряд отрисовывается друг под другом путем выполнения XOR с текущими значениями пикселей. Если в процессе отрисовки любой пиксель был переведен из состояния 1 в 0, то в `vF` нужно записаться 1, в противном случае 0.

### Таймеры

**FX15**  
Установить в таймер задержки значение из регистра `vX`.

**FX18**  
Установить в таймер звука значение из регистра `vX`.

### Клавиатура

**FX0A**  
Дождаться нажатия и отжатия любой клавиши. Установить в регистр `vX` значение этой клавиши.

### Работа с адресами

**1NNN**  
Done
Перейти на адрес `0xNNN`.

**2NNN**  
Done
Положить на стек адрес возврата и перейти к выполнению подпрограммы по адресу `0xNNN`.

**00EE**  
Done
Вернуться из подпрограммы на адрес сверху стека.

**BNNN**  
Done
Перейти на адресс `NNN + v0`.

### ????

**0NNN**  
Перейти к выполнению подпрограммы по адресу `0xNNN`.

**FX29**  
???
